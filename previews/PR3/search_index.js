var documenterSearchIndex = {"docs":
[{"location":"readers/#BGZF-readers","page":"Readers","title":"BGZF readers","text":"","category":"section"},{"location":"readers/#BGZFReader-and-SyncBGZFReader","page":"Readers","title":"BGZFReader and SyncBGZFReader","text":"","category":"section"},{"location":"readers/","page":"Readers","title":"Readers","text":"BGZFLib exposes two readers:","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"BGZFReader uses a number of worker tasks to decompress concurrently with reading. This gives the highest performance and should be the default choice. However, in my experience Julia's task scheduler is not fantastic and can cause performance problems.\nSyncBGZFReader avoids task scheduling by decompressing in the reading task. Therefore, it neither decompresses in parallel, nor concurrent with reading, which makes it slower. However, it is simpler, less likely to have bugs, and does not strain the scheduler.","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"Most users should use BGZFReader.","category":"page"},{"location":"readers/#Constructing-BGZF-readers","page":"Readers","title":"Constructing BGZF readers","text":"","category":"section"},{"location":"readers/","page":"Readers","title":"Readers","text":"Both readers make use of the AbstractBufReader interface. They both contain un-expandable buffers, i.e. fill_buffer generally cannot expand the buffer size and will return nothing if the buffer is not empty.","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"Readers wrap another AbstractBufReader containing the compressed BGZF stream:","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"using BufferIO\nusing BGZFLib\n\nreader = CursorReader(bgzf_data);\n@assert reader isa AbstractBufReader\nbgzf_reader = BGZFReader(reader)\nprintln(String(read(bgzf_reader))) \nclose(bgzf_reader)\n\n# output\nHello, world!more dataxthen some moremore content herethis is another block","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"The AbstractBufReader must be able to buffer a full BGZF block, or the remainder of the underlying file, whichever is smallest.","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"If an AbstractBufReader with less space is provided, a BGZFError(nothing, BGZFErrors.insufficient_reader_space) is thrown.","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"If a reader is constructed from an IO, it is automatically wrapped in a BufReader with an appropriate buffer size:","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"bgzf_reader = SyncBGZFReader(IOBuffer(bgzf_data))\nprintln(String(read(bgzf_reader))) \nclose(bgzf_reader)\n\n# output\nHello, world!more dataxthen some moremore content herethis is another block","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"Mutating the wrapped io object of a BGZF reader or writer is not permitted and can cause erratic behaviour.","category":"page"},{"location":"readers/#Reading-BGZF-files","page":"Readers","title":"Reading BGZF files","text":"","category":"section"},{"location":"readers/","page":"Readers","title":"Readers","text":"Readers have a check_truncated keyword that defaults to true. If set to true, the reader will error if the last block in the stream is not empty, marking EOF:","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"Example with check_truncated = true (default)","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"reader = CursorReader(bgzf_data[1:end-28])\nString(read(BGZFReader(reader)))\n\n# output\nERROR: BGZFError(0, BGZFLib.BGZFErrors.truncated_file)\n[...]","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"And set to false","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"reader = CursorReader(bgzf_data[1:end-28])\nString(read(BGZFReader(reader; check_truncated = false)))\n\n# output\n\"Hello, world!more dataxthen some moremore content herethis is another block\"","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"Like Base.open, the BGZF readers also have a method that takes a function as a first argument, and makes sure to close the reader even if it errors:","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"SyncBGZFReader(io -> String(read(io)), CursorReader(bgzf_data))\n\n# output\n\"Hello, world!more dataxthen some moremore content herethis is another block\"","category":"page"},{"location":"readers/#Errors-and-error-recovery","page":"Readers","title":"Errors and error recovery","text":"","category":"section"},{"location":"readers/","page":"Readers","title":"Readers","text":"Types in this package generally throw BGZFErrors:","category":"page"},{"location":"readers/#BGZFLib.BGZFError-readers","page":"Readers","title":"BGZFLib.BGZFError","text":"BGZFError <: Exception\n\nException type thrown by BGZF readers and writers, when encountering errors specific to the BGZF (or gzip, or DEFLATE) formats. Note that exceptions thrown by BGZF readers and writers are not guaranteed to be of this type, as they may also throw BufferIO.IOErrors, or exceptions propagated by their underlying IO.\n\nThis error contains two public properties:\n\nblock_offset::Union{Nothing, Int} gives the zero-based offset in the compressed stream  of the block where the error occurred.  Some errors may not occur at a specific block, in which case this is nothing.\ntype::Union{BGZFErrorType, LibDeflateError}. If the blocks are malformed gzip blocks, this  is a LibDeflateError. Else, if the error is specific to the BGZF format, it's a BGZFErrorType.\n\n\n\n\n\n","category":"type"},{"location":"readers/#BGZFLib.BGZFErrors-readers","page":"Readers","title":"BGZFLib.BGZFErrors","text":"module BGZFErrors\n\nThis module is used as a namespace for the enum BGZFErrorType. The enum is non-exhaustive (more variants may be added in the future). The current values are:\n\ntruncated_file: The reader data stops abruptly. Either in the middle of a block, or there is no empty block at EOF\nmissing_bc_field: A block has no BC field, or it's malformed\nblock_offset_out_of_bounds: Seek with a VirtualOffset where the block offset is larger than the block size\ninsufficient_reader_space: The BGZF reader wraps an AbstractBufWriter that is not EOF, and its buffer can't grow to encompass a whole BGZF block\ninsufficient_writer_space: A BGZF writer wraps an AbstractBufWriter whose buffer cannot grow to encompass a full BGZF block\nunsorted_index: Attempted to load a malformed GZI file with unsorted coordinates\noperation_on_error: Attempted an operation on a BGZF reader or writer in an error state.\n\n\n\n\n\n","category":"module"},{"location":"readers/","page":"Readers","title":"Readers","text":"However, some operations on BGZF readers and writers propagate to their underlying IO, which may throw different errors. For example, when calling seek on a BGZF reader wrapping a file (e.g. SyncBGZFReader{BufReader{IOStream}}), seek is also called on the underlying IOStream. This may throw another error.","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"When attempting to read a malformed BGZF file, the reader will throw a BGZFError and be in an error state. In this state, some operations like BufferIO.fill_buffer and Base.seek will throw a BGZFError(nothing, BGZFErrors.operation_on_error).","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"To recover the BGZF reader, seek to a valid position:","category":"page"},{"location":"readers/","page":"Readers","title":"Readers","text":"bad_data = append!(copy(bgzf_data), \"some bad data\")\nreader = BGZFReader(CursorReader(bad_data))\n\n# Trigger an error from reading bad gzip data\ntry\n    read(reader)\ncatch error\n    @assert error isa BGZFError\n    @assert error.type isa LibDeflateError\nend\n\n# Trying to read from a reader in an error state will throw\n# a BGZF error.\n# Note that e.g. calling `read` would throw the same error\ntry\n    fill_buffer(reader)\ncatch error\n    @assert error isa BGZFError\n    @assert error.type === BGZFErrors.operation_on_error\nend\n\n# Reset the reader by calling `seek`. If seek succeeds, the error\n# state will disappear.\nseekstart(reader)\nprintln(String(read(reader, 13)))\nclose(reader)\n\n# output\nHello, world!\n","category":"page"},{"location":"readers/#Reference","page":"Readers","title":"Reference","text":"","category":"section"},{"location":"readers/#BGZFLib.BGZFReader-readers","page":"Readers","title":"BGZFLib.BGZFReader","text":"BGZFReader(io::T <: IO; n_workers::Int, check_truncated::Bool=true)::BGZFReader{BufReader{T}}\nBGZFReader(io::T <: AbstractBufReader; n_workers::Int, check_truncated::Bool=true)::BGZFReader{T}\n\nCreate a BGZFReader <: AbstractBufReader that decompresses a BGZF stream.\n\nWhen constructing from an io::AbstractBufReader, io must have a buffer size of at least 65536, or be able to grow its buffer to this size.\n\nIf check_truncated, the last BGZF block in the file must be empty, otherwise the reader throws an error. This can be used to detect the file was truncated.\n\nThe decompression happens asyncronously in a set of worker tasks. To avoid spawning workers, use the SyncBGZFReader instead.\n\nIf the reader encounters an error, it goes into an error state and throws an exception. The reader can be reset by using seek or seekstart. A closed reader cannot be reset.\n\n\n\n\n\n","category":"type"},{"location":"readers/#BGZFLib.SyncBGZFReader-readers","page":"Readers","title":"BGZFLib.SyncBGZFReader","text":"SyncBGZFReader(io::T <: IO; check_truncated::Bool=true)::SyncBGZFReader{BufReader{T}}\nSyncBGZFReader(io::T <: AbstractBufReader; check_truncated::Bool=true)::SyncBGZFReader{T}\n\nCreate a SyncBGZFReader <: AbstractBufReader that decompresses BGZF files.\n\nWhen constructing from an io::AbstractBufReader, io must have a buffer size of at least 65536, or be able to grow its buffer to this size.\n\nIf check_truncated, the last BGZF block in the file must be empty, otherwise the reader throws an error. This can be used to detect the file was truncated.\n\nUnlike BGZFReader, the decompression happens in in serial in the main task. This is slower and does not enable paralellism, but may be preferable in situations where task scheduling or contention is an issue.\n\nIf the reader encounters an error, it goes into an error state and throws an exception. The reader can be reset by using seek or seekstart. A closed reader cannot be reset.\n\n\n\n\n\n","category":"type"},{"location":"gzindex/#Seeking-BGZF-files","page":"Seeking","title":"Seeking BGZF files","text":"","category":"section"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"Due to their blocked nature, it is possible to seek BGZF files, and to index them to support seeking to any position in the equivalent decompressed stream.","category":"page"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"Currently, only BGZF reader support seeking. Seek support for writers may be added in the future.","category":"page"},{"location":"gzindex/#Virtual-seeking","page":"Seeking","title":"Virtual seeking","text":"","category":"section"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"A BGZF reader is seeked with a virtual offset, which contains two offsets: The file offset, which is the offset in the compressed stream that marks the start of the compressed BGZF block, and the block offset, the offset in the decompressed content of that block.","category":"page"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"This is modeled by the VirtualOffset:","category":"page"},{"location":"gzindex/#BGZFLib.VirtualOffset-gzindex","page":"Seeking","title":"BGZFLib.VirtualOffset","text":"VirtualOffset(file_offset::Integer, block_offset::Integer)\n\nCreate a BGZF virtual file offset from file_offset and block_offset. Get the two offsets with the public properties vo.file_offset and vo.block_offset\n\nA VirtualOffset contains the two zero-indexed offset: The \"file offset\", which is the offset in the compressed BGZF file that marks the beginning of the block with the given position, and an \"block offset\" which is the offset of the uncompressed content of that block.\n\nThe valid ranges of these two are 0:2^48-1 and 0:2^16-1, respectively.\n\nExamples\n\njulia> reader = SyncBGZFReader(CursorReader(bgzf_data));\n\njulia> vo = VirtualOffset(178, 5)\nVirtualOffset(178, 5)\n\njulia> virtual_seek(reader, vo);\n\njulia> String(read(reader, 9))\n\"some more\"\n\njulia> virtual_seek(reader, VirtualOffset(0, 7));\n\njulia> String(read(reader, 6))\n\"world!\"\n\n\n\n\n\n","category":"type"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"The current VirtualOffset position is obtained with virtual_position, and seeking is done with virtual_seek:","category":"page"},{"location":"gzindex/#BGZFLib.virtual_position-gzindex","page":"Seeking","title":"BGZFLib.virtual_position","text":"virtual_position(io::Union{SyncBGZFReader, BGZFReader})::VirtualOffset\n\nGet the VirtualOffset of the current BGZF reader. The virtual offset is a position in the decompressed stream. Seek to the position using virtual_seek.\n\nSee also: VirtualOffset, virtual_seek\n\nExamples\n\njulia> reader = SyncBGZFReader(CursorReader(bgzf_data));\n\njulia> virtual_position(reader)\nVirtualOffset(0, 0)\n\njulia> read(reader, 18);\n\njulia> virtual_position(reader)\nVirtualOffset(44, 5)\n\njulia> close(reader)\n\n\n\n\n\n","category":"function"},{"location":"gzindex/#BGZFLib.virtual_seek-gzindex","page":"Seeking","title":"BGZFLib.virtual_seek","text":"virtual_seek(io::Union{SyncBGZFReader, BGZFReader}, vo::VirtualOffset) -> io\n\nSeek to the virtual position vo. The virtual position is usually obtained by a call to virtual_position.\n\nSee also: VirtualOffset, virtual_position\n\njulia> reader = SyncBGZFReader(CursorReader(bgzf_data));\n\njulia> virtual_seek(reader, VirtualOffset(178, 14));\n\njulia> String(read(reader))\n\"more content herethis is another block\"\n\njulia> virtual_seek(reader, VirtualOffset(0, 0));\n\njulia> String(read(reader, 13))\n\"Hello, world!\"\n\njulia> close(reader)\n\n\n\n\n\n","category":"function"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"BGZF readers also supports Base.seek. Calling seek(io, x) is equivalent to virtual_seek(io, VirtualOffset(x, 0)):","category":"page"},{"location":"gzindex/#Base.seek-Tuple{SyncBGZFReader, Int64}-gzindex","page":"Seeking","title":"Base.seek","text":"seek(io::Union{SyncBGZFReader, BGZFReader}, offset::Int)\n\nSeek to the zero-indexed position in the compressed stream offset. This position must be the beginning of a BGZF block, else the reader will error when trying to read after the seek. seek(io, offset) is equivalent to seek(io, VirtualOffset(offset, 0)). seek(io, 0) works, and is equivalent to seekstart(io).\n\nExamples\n\njulia> reader = BGZFReader(CursorReader(bgzf_data));\n\njulia> seek(reader, 44);\n\njulia> read(reader, String)\n\"more dataxthen some moremore content herethis is another block\"\n\njulia> seek(reader, 45); # NB: Not start of BGZF block\n\njulia> read(reader, UInt8)\nERROR: BGZFError(0, LibDeflate.LibDeflateErrors.gzip_bad_magic_bytes)\n\njulia> close(reader)\n\n\n\n\n\n","category":"method"},{"location":"gzindex/#Seeking-with-GZIndex","page":"Seeking","title":"Seeking with GZIndex","text":"","category":"section"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"In order to seek to a certain decompressed offset, e.g. to seek to the 10,000th byte in a decompressed stream, you need to know the offset of the BGZF block that contains this byte in the compressed stream. This can be efficiently obtained with a GZIndex.","category":"page"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"An index::GZIndex value contains the (public) property index.blocks, which is a Vector{@NamedTuple{compressed_offset::UInt64, decompressed_offset::UInt64}}, with one element for each block in the corresponding file. All the values of compressed_offset and decompressed_offset are guaranteed to be sorted in ascending order in a GZIndex:","category":"page"},{"location":"gzindex/#BGZFLib.GZIndex-gzindex","page":"Seeking","title":"BGZFLib.GZIndex","text":"GZIndex(blocks::Vector{@NamedTuple{compressed_offset::UInt64, decompressed_offset::UInt64}})\n\nConstruct a GZI index of a BGZF file. The vector blocks contains one pair of integers for each block in the BGZF file, in order, containing the zero-based offset of the compressed data and the corresponding decompressed data, respectively.\n\nThrow a BGZFError(nothing, BGZFErrors.unsorted_index) if either of the offsets are not sorted in ascending order.\n\nUsually constructed with index_bgzf, or load_gzi and serialized with write(io, ::GZIndex).\n\nThis struct contains the public property .blocks which corresponds to the vector as described above, no matter how GZIndex is constructed.\n\nSee also: index_bgzf, load_gzi, write_gzi\n\n\n\n\n\n","category":"type"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"Let's say you want to seek to the decompressed offset 37 in our example BGZF file. The approach is this:","category":"page"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"Find the first block with a decompressed offset D <= 37. Since .blocks is sorted, you can use binary search for this.\nVirtualseek to VirtalOffset(D, 37 - D)","category":"page"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"gzi = load_gzi(CursorReader(gzi_data))\nreader = SyncBGZFReader(CursorReader(bgzf_data))\n\n# Use `searchsortedlast` to find the last block with a decompressed offset\n# <= 37, i.e. the block containing the decompressed offset 37.\ntarget_block = (;compressed_offset=0, decompressed_offset=37)\nidx = searchsortedlast(gzi.blocks, target_block, by=i -> i.decompressed_offset)\n(;compressed_offset, decompressed_offset) = gzi.blocks[idx]\nvirtual_seek(reader, VirtualOffset(compressed_offset, 37 - decompressed_offset))\nread(reader) |> String\n\n# output\n\"more content herethis is another block\"","category":"page"},{"location":"gzindex/#Building-a-GZIndex","page":"Seeking","title":"Building a GZIndex","text":"","category":"section"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"A GZIndex can be constructed manually from a correct (and sorted) vector v of the above mentioned type using GZIndex(v). More commonly, it is either computed from a BGZF file, or directly loaded from a GZI file:","category":"page"},{"location":"gzindex/#BGZFLib.index_bgzf-gzindex","page":"Seeking","title":"BGZFLib.index_bgzf","text":"index_bgzf(io::Union{IO, AbstractBufReader})::GZIndex\n\nCompute a GZIndex from a BGZF file.\n\nThrow a BGZFError if the BGZF file is invalid, or a BGZFError with BGZFErrors.insufficient_reader_space if an entire block cannot be buffered by io, (only happens if io::AbstractBufReader).\n\nIndexing the file does not attempt to decompress it, and therefore does not validate that the compressed data is valid (i.e. is a valid DEFLATE payload, or that the crc32 checksum matches).\n\nSee also: load_gzi, GZIndex, write_gzi\n\nExamples\n\njulia> idx1 = open(index_bgzf, path_to_bgzf);\n\njulia> idx2 = open(load_gzi, path_to_gzi);\n\njulia> idx1.blocks == idx2.blocks\ntrue\n\n\n\n\n\n","category":"function"},{"location":"gzindex/#BGZFLib.load_gzi-gzindex","page":"Seeking","title":"BGZFLib.load_gzi","text":"load_gzi(io::Union{IO, AbstractBufReader})::GZIndex\n\nLoad a GZIndex from a GZI file.\n\nThrow an IOError(IOErrorKinds.EOF) if io does not contain enough bytes for a valid GZI file. Throw a BGZFError(nothing, BGZFErrors.unsorted_index) if the offsets are not sorted in ascending order. Currently does not throw an error if the file contains extra appended bytes, but this may change in the future.\n\nSee also: index_bgzf, GZIndex, write_gzi\n\nExamples\n\njulia> gzi = open(load_gzi, path_to_gzi);\n\njulia> gzi isa GZIndex\ntrue\n\njulia> (; compressed_offset) = gzi.blocks[5]\n(compressed_offset = 0x0000000000000093, decompressed_offset = 0x0000000000000017)\n\njulia> reader = SyncBGZFReader(CursorReader(bgzf_data));\n\njulia> seek(reader, Int(compressed_offset));\n\njulia> read(reader, 15) |> String\n\"then some morem\"\n\njulia> close(reader)\n\n\n\n\n\n","category":"function"},{"location":"gzindex/#Writing-GZI-files","page":"Seeking","title":"Writing GZI files","text":"","category":"section"},{"location":"gzindex/","page":"Seeking","title":"Seeking","text":"This is done with write_gzi:","category":"page"},{"location":"gzindex/#BGZFLib.write_gzi-gzindex","page":"Seeking","title":"BGZFLib.write_gzi","text":"write_gzi(io::Union{AbstractBufWriter, IO}, index::GZIndex)::Int\n\nWrite a GZIndex to io in GZI format, and return the number of written bytes. Currently, this function only works on little-endian CPUs, and will throw an ErrorException on big-endian platforms.\n\nThe resulting file can be loaded with load_gzi and obtain an index equivalent to index.\n\nSee also: GZIndex, index_bgzf    \n\nExamples\n\njulia> gzi = load_gzi(CursorReader(gzi_data))::GZIndex;\n\njulia> io = VecWriter();\n\njulia> write_gzi(io, gzi)\n152\n\njulia> gzi_2 = load_gzi(CursorReader(io.vec));\n\njulia> gzi.blocks == gzi_2.blocks\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#BGZFLib.BGZFError","page":"Reference","title":"BGZFLib.BGZFError","text":"BGZFError <: Exception\n\nException type thrown by BGZF readers and writers, when encountering errors specific to the BGZF (or gzip, or DEFLATE) formats. Note that exceptions thrown by BGZF readers and writers are not guaranteed to be of this type, as they may also throw BufferIO.IOErrors, or exceptions propagated by their underlying IO.\n\nThis error contains two public properties:\n\nblock_offset::Union{Nothing, Int} gives the zero-based offset in the compressed stream  of the block where the error occurred.  Some errors may not occur at a specific block, in which case this is nothing.\ntype::Union{BGZFErrorType, LibDeflateError}. If the blocks are malformed gzip blocks, this  is a LibDeflateError. Else, if the error is specific to the BGZF format, it's a BGZFErrorType.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BGZFLib.BGZFReader","page":"Reference","title":"BGZFLib.BGZFReader","text":"BGZFReader(io::T <: IO; n_workers::Int, check_truncated::Bool=true)::BGZFReader{BufReader{T}}\nBGZFReader(io::T <: AbstractBufReader; n_workers::Int, check_truncated::Bool=true)::BGZFReader{T}\n\nCreate a BGZFReader <: AbstractBufReader that decompresses a BGZF stream.\n\nWhen constructing from an io::AbstractBufReader, io must have a buffer size of at least 65536, or be able to grow its buffer to this size.\n\nIf check_truncated, the last BGZF block in the file must be empty, otherwise the reader throws an error. This can be used to detect the file was truncated.\n\nThe decompression happens asyncronously in a set of worker tasks. To avoid spawning workers, use the SyncBGZFReader instead.\n\nIf the reader encounters an error, it goes into an error state and throws an exception. The reader can be reset by using seek or seekstart. A closed reader cannot be reset.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BGZFLib.BGZFWriter","page":"Reference","title":"BGZFLib.BGZFWriter","text":"BGZFWriter(io::T <: AbstractBufWriter; kwargs)::BGZFWriter{T}\nBGZFWriter(io::T <: IO; kwargs)::BGZFWriter{BufWriter{T}}\n\nCreate a SyncBGZFWriter <: AbstractBufWriter that writes compresses data written to it, and writes the compressed BGZF file to the underlying io.\n\nThis type differs from SyncBGZFWriter in that the compression happens in separate worker tasks. This allows BGZFWriter to compress in parallel, making it faster in the presence of multiple threads.\n\nIf io::AbstractBufWriter, io must be able to buffer up to 2^16 bytes, else a BGZFError(nothing, BGZFErrors.insufficient_writer_space) is thrown.\n\nThe keyword arguments are:\n\nn_workers::Int: Set number of workers. Must be > 0. Defaults to some small number.\ncompress_level::Int: Set compression level from 1 to 12, with 12 being slowest but with the best compression ratio. It defaults to an intermediate level of compression.\nappend_empty::Bool = true. If set, closing the SyncBGZFWriter will write an empty BGZF block, indicating EOF.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BGZFLib.GZIndex","page":"Reference","title":"BGZFLib.GZIndex","text":"GZIndex(blocks::Vector{@NamedTuple{compressed_offset::UInt64, decompressed_offset::UInt64}})\n\nConstruct a GZI index of a BGZF file. The vector blocks contains one pair of integers for each block in the BGZF file, in order, containing the zero-based offset of the compressed data and the corresponding decompressed data, respectively.\n\nThrow a BGZFError(nothing, BGZFErrors.unsorted_index) if either of the offsets are not sorted in ascending order.\n\nUsually constructed with index_bgzf, or load_gzi and serialized with write(io, ::GZIndex).\n\nThis struct contains the public property .blocks which corresponds to the vector as described above, no matter how GZIndex is constructed.\n\nSee also: index_bgzf, load_gzi, write_gzi\n\n\n\n\n\n","category":"type"},{"location":"reference/#BGZFLib.SyncBGZFReader","page":"Reference","title":"BGZFLib.SyncBGZFReader","text":"SyncBGZFReader(io::T <: IO; check_truncated::Bool=true)::SyncBGZFReader{BufReader{T}}\nSyncBGZFReader(io::T <: AbstractBufReader; check_truncated::Bool=true)::SyncBGZFReader{T}\n\nCreate a SyncBGZFReader <: AbstractBufReader that decompresses BGZF files.\n\nWhen constructing from an io::AbstractBufReader, io must have a buffer size of at least 65536, or be able to grow its buffer to this size.\n\nIf check_truncated, the last BGZF block in the file must be empty, otherwise the reader throws an error. This can be used to detect the file was truncated.\n\nUnlike BGZFReader, the decompression happens in in serial in the main task. This is slower and does not enable paralellism, but may be preferable in situations where task scheduling or contention is an issue.\n\nIf the reader encounters an error, it goes into an error state and throws an exception. The reader can be reset by using seek or seekstart. A closed reader cannot be reset.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BGZFLib.SyncBGZFWriter","page":"Reference","title":"BGZFLib.SyncBGZFWriter","text":"SyncBGZFWriter(io::T <: AbstractBufWriter; kwargs)::SyncBGZFWriter{T}\nSyncBGZFWriter(io::T <: IO; kwargs)::SyncBGZFWriter{BufWriter{T}}\n\nCreate a SyncBGZFWriter <: AbstractBufWriter that writes compresses data written to it, and writes the compressed BGZF file to the underlying io.\n\nThis type differs from BGZFWriter in that it does the compression serial in the main task. Therefore it is slower when multiple threads are present, but does not incur Task- and scheduling overhead.\n\nIf io::AbstractBufWriter, io must be able to buffer up to 2^16 bytes, else a BGZFError(nothing, BGZFErrors.insufficient_writer_space) is thrown.\n\nThe keyword arguments are:\n\ncompresslevel::Int: Set compression level from 1 to 12, with 12 being slowest but with the best compression ratio. It defaults to an intermediate level of compression.\nappend_empty::Bool = true. If set, closing the SyncBGZFWriter will write an empty BGZF block, indicating EOF.\n\n\n\n\n\n","category":"type"},{"location":"reference/#BGZFLib.VirtualOffset","page":"Reference","title":"BGZFLib.VirtualOffset","text":"VirtualOffset(file_offset::Integer, block_offset::Integer)\n\nCreate a BGZF virtual file offset from file_offset and block_offset. Get the two offsets with the public properties vo.file_offset and vo.block_offset\n\nA VirtualOffset contains the two zero-indexed offset: The \"file offset\", which is the offset in the compressed BGZF file that marks the beginning of the block with the given position, and an \"block offset\" which is the offset of the uncompressed content of that block.\n\nThe valid ranges of these two are 0:2^48-1 and 0:2^16-1, respectively.\n\nExamples\n\njulia> reader = SyncBGZFReader(CursorReader(bgzf_data));\n\njulia> vo = VirtualOffset(178, 5)\nVirtualOffset(178, 5)\n\njulia> virtual_seek(reader, vo);\n\njulia> String(read(reader, 9))\n\"some more\"\n\njulia> virtual_seek(reader, VirtualOffset(0, 7));\n\njulia> String(read(reader, 6))\n\"world!\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#BGZFLib.index_bgzf-Tuple{IO}","page":"Reference","title":"BGZFLib.index_bgzf","text":"index_bgzf(io::Union{IO, AbstractBufReader})::GZIndex\n\nCompute a GZIndex from a BGZF file.\n\nThrow a BGZFError if the BGZF file is invalid, or a BGZFError with BGZFErrors.insufficient_reader_space if an entire block cannot be buffered by io, (only happens if io::AbstractBufReader).\n\nIndexing the file does not attempt to decompress it, and therefore does not validate that the compressed data is valid (i.e. is a valid DEFLATE payload, or that the crc32 checksum matches).\n\nSee also: load_gzi, GZIndex, write_gzi\n\nExamples\n\njulia> idx1 = open(index_bgzf, path_to_bgzf);\n\njulia> idx2 = open(load_gzi, path_to_gzi);\n\njulia> idx1.blocks == idx2.blocks\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#BGZFLib.load_gzi-Tuple{IO}","page":"Reference","title":"BGZFLib.load_gzi","text":"load_gzi(io::Union{IO, AbstractBufReader})::GZIndex\n\nLoad a GZIndex from a GZI file.\n\nThrow an IOError(IOErrorKinds.EOF) if io does not contain enough bytes for a valid GZI file. Throw a BGZFError(nothing, BGZFErrors.unsorted_index) if the offsets are not sorted in ascending order. Currently does not throw an error if the file contains extra appended bytes, but this may change in the future.\n\nSee also: index_bgzf, GZIndex, write_gzi\n\nExamples\n\njulia> gzi = open(load_gzi, path_to_gzi);\n\njulia> gzi isa GZIndex\ntrue\n\njulia> (; compressed_offset) = gzi.blocks[5]\n(compressed_offset = 0x0000000000000093, decompressed_offset = 0x0000000000000017)\n\njulia> reader = SyncBGZFReader(CursorReader(bgzf_data));\n\njulia> seek(reader, Int(compressed_offset));\n\njulia> read(reader, 15) |> String\n\"then some morem\"\n\njulia> close(reader)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BGZFLib.virtual_position-Tuple{SyncBGZFReader}","page":"Reference","title":"BGZFLib.virtual_position","text":"virtual_position(io::Union{SyncBGZFReader, BGZFReader})::VirtualOffset\n\nGet the VirtualOffset of the current BGZF reader. The virtual offset is a position in the decompressed stream. Seek to the position using virtual_seek.\n\nSee also: VirtualOffset, virtual_seek\n\nExamples\n\njulia> reader = SyncBGZFReader(CursorReader(bgzf_data));\n\njulia> virtual_position(reader)\nVirtualOffset(0, 0)\n\njulia> read(reader, 18);\n\njulia> virtual_position(reader)\nVirtualOffset(44, 5)\n\njulia> close(reader)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BGZFLib.virtual_seek-Tuple{SyncBGZFReader, VirtualOffset}","page":"Reference","title":"BGZFLib.virtual_seek","text":"virtual_seek(io::Union{SyncBGZFReader, BGZFReader}, vo::VirtualOffset) -> io\n\nSeek to the virtual position vo. The virtual position is usually obtained by a call to virtual_position.\n\nSee also: VirtualOffset, virtual_position\n\njulia> reader = SyncBGZFReader(CursorReader(bgzf_data));\n\njulia> virtual_seek(reader, VirtualOffset(178, 14));\n\njulia> String(read(reader))\n\"more content herethis is another block\"\n\njulia> virtual_seek(reader, VirtualOffset(0, 0));\n\njulia> String(read(reader, 13))\n\"Hello, world!\"\n\njulia> close(reader)\n\n\n\n\n\n","category":"method"},{"location":"reference/#BGZFLib.write_empty_block-Tuple{SyncBGZFWriter}","page":"Reference","title":"BGZFLib.write_empty_block","text":"write_empty_block(io::Union{SyncBGZFWriter, BGZFWriter})\n\nPerform a shallow_flush, then write an empty block.\n\nExamples\n\nWrite the final empty EOF block manually:\n\njulia> io = VecWriter();\n\njulia> SyncBGZFWriter(io; append_empty=false) do writer\n           write(writer, \"Hello\")\n           # Manually write the empty EOF block\n           write_empty_block(writer)\n       end\n\njulia> SyncBGZFReader(CursorReader(io.vec); check_truncated=true) do reader\n           read(reader, String)\n       end\n\"Hello\"\n\n\n\n\n\n","category":"method"},{"location":"reference/#BGZFLib.write_gzi-Tuple{Union{BufferIO.AbstractBufWriter, IO}, GZIndex}","page":"Reference","title":"BGZFLib.write_gzi","text":"write_gzi(io::Union{AbstractBufWriter, IO}, index::GZIndex)::Int\n\nWrite a GZIndex to io in GZI format, and return the number of written bytes. Currently, this function only works on little-endian CPUs, and will throw an ErrorException on big-endian platforms.\n\nThe resulting file can be loaded with load_gzi and obtain an index equivalent to index.\n\nSee also: GZIndex, index_bgzf    \n\nExamples\n\njulia> gzi = load_gzi(CursorReader(gzi_data))::GZIndex;\n\njulia> io = VecWriter();\n\njulia> write_gzi(io, gzi)\n152\n\njulia> gzi_2 = load_gzi(CursorReader(io.vec));\n\njulia> gzi.blocks == gzi_2.blocks\ntrue\n\n\n\n\n\n","category":"method"},{"location":"reference/#BGZFLib.BGZFErrors","page":"Reference","title":"BGZFLib.BGZFErrors","text":"module BGZFErrors\n\nThis module is used as a namespace for the enum BGZFErrorType. The enum is non-exhaustive (more variants may be added in the future). The current values are:\n\ntruncated_file: The reader data stops abruptly. Either in the middle of a block, or there is no empty block at EOF\nmissing_bc_field: A block has no BC field, or it's malformed\nblock_offset_out_of_bounds: Seek with a VirtualOffset where the block offset is larger than the block size\ninsufficient_reader_space: The BGZF reader wraps an AbstractBufWriter that is not EOF, and its buffer can't grow to encompass a whole BGZF block\ninsufficient_writer_space: A BGZF writer wraps an AbstractBufWriter whose buffer cannot grow to encompass a full BGZF block\nunsorted_index: Attempted to load a malformed GZI file with unsorted coordinates\noperation_on_error: Attempted an operation on a BGZF reader or writer in an error state.\n\n\n\n\n\n","category":"module"},{"location":"#BGZFLib","page":"BGZFLib","title":"BGZFLib","text":"","category":"section"},{"location":"","page":"BGZFLib","title":"BGZFLib","text":"BGFLib.jl is a package for reading and writing BGZF files. See the sections in the side bar.","category":"page"},{"location":"#Example-use","page":"BGZFLib","title":"Example use","text":"","category":"section"},{"location":"","page":"BGZFLib","title":"BGZFLib","text":"# Decompress a file\nBGZFReader(open(\"file.bam\")) do reader\n    decompressed = read(reader)\nend\n\n# Compress it again\nBGZFWriter(open(\"another.bam\", \"w\")) do reader\n    write(reader, decompressed)\nend","category":"page"},{"location":"#Comparison-with-other-packages","page":"BGZFLib","title":"Comparison with other packages","text":"","category":"section"},{"location":"#BGZFStreams.jl","page":"BGZFLib","title":"BGZFStreams.jl","text":"","category":"section"},{"location":"","page":"BGZFLib","title":"BGZFLib","text":"BGZFLib exposes the AbstractBufReader interface from BufferIO.jl. This interface gives more control to the user and is better documented.\nBGZFLib is faster. Here are some timings on my laptop to decompress a 3,9 GiB BAM file for BGZFStreams and BGZFLib, respectively:","category":"page"},{"location":"","page":"BGZFLib","title":"BGZFLib","text":"threads BGZFStreams BGZFLib\n1             27.0    12.3\n2             15.3     6.50\n4              9.16    3.45\n8              6.73    2.33","category":"page"},{"location":"","page":"BGZFLib","title":"BGZFLib","text":"BGFLib is async, in the sense that (de)compression happens concurrent with reading and writing. In contrast, BGZFStream pauses reading/writing to (de)compress in parallel. ","category":"page"},{"location":"#CodecBGZF.jl","page":"BGZFLib","title":"CodecBGZF.jl","text":"","category":"section"},{"location":"","page":"BGZFLib","title":"BGZFLib","text":"CodecBGZF.jl is deprecated and should not be used.","category":"page"},{"location":"writers/#BGZF-writers","page":"Writers","title":"BGZF writers","text":"","category":"section"},{"location":"writers/","page":"Writers","title":"Writers","text":"Like BGZF readers, there is a BGZFWriter and a SyncBGZFWriter with the same tradeoffs as the two readers. See the \"readers\" section in the sidebar.","category":"page"},{"location":"writers/#Constructing-BGZF-writers","page":"Writers","title":"Constructing BGZF writers","text":"","category":"section"},{"location":"writers/","page":"Writers","title":"Writers","text":"Both BGZF writers conform to the AbstractBufWriter interface.","category":"page"},{"location":"writers/","page":"Writers","title":"Writers","text":"The buffers of the BGZF writers are fixed in size. Calling BufferIO.grow_buffer on them will perform a shallow flush instead of expanding the buffer.","category":"page"},{"location":"writers/","page":"Writers","title":"Writers","text":"The SyncBGZFWriter wraps an existing AbstractBufWriter. This inner writer must be able to present a buffer of at least size 2^16, else a BGZFError(nothing, BGZFErrors.insufficient_writer_space) will be thrown.","category":"page"},{"location":"writers/","page":"Writers","title":"Writers","text":"When creating a SyncBGZFWriter from an T <: IO, a SyncBGZFWriter{BufWriter{T}} is created. Since BufWriter has an expanding buffer, it can always accomodate 2^16 bytes.","category":"page"},{"location":"writers/","page":"Writers","title":"Writers","text":"Mutating the wrapped io object of a BGZF reader or writer is not permitted and can cause erratic behaviour.","category":"page"},{"location":"writers/#Writing-BGZF-files","page":"Writers","title":"Writing BGZF files","text":"","category":"section"},{"location":"writers/","page":"Writers","title":"Writers","text":"Writers have an append_empty keyword that defaults to true. If set to true, closing the BGZF writer will write an empty BGZF, signaling EOF.","category":"page"},{"location":"writers/","page":"Writers","title":"Writers","text":"Should you want to write an empty block in the middle of the stream, ehe function write_empty_block can be used:","category":"page"},{"location":"writers/#BGZFLib.write_empty_block-writers","page":"Writers","title":"BGZFLib.write_empty_block","text":"write_empty_block(io::Union{SyncBGZFWriter, BGZFWriter})\n\nPerform a shallow_flush, then write an empty block.\n\nExamples\n\nWrite the final empty EOF block manually:\n\njulia> io = VecWriter();\n\njulia> SyncBGZFWriter(io; append_empty=false) do writer\n           write(writer, \"Hello\")\n           # Manually write the empty EOF block\n           write_empty_block(writer)\n       end\n\njulia> SyncBGZFReader(CursorReader(io.vec); check_truncated=true) do reader\n           read(reader, String)\n       end\n\"Hello\"\n\n\n\n\n\n","category":"function"},{"location":"writers/","page":"Writers","title":"Writers","text":"Similar to BGZF readers (and Base.open), you can pass a function as the first argument to apply the function to the reader, then automatically close it:","category":"page"},{"location":"writers/","page":"Writers","title":"Writers","text":"io = VecWriter()\n\n# Write data to `io` in BGZF format\nBGZFWriter(io) do writer\n    write(writer, \"Hello, world!\")\nend\n\n# Now read it back\nSyncBGZFReader(CursorReader(io.vec)) do reader\n    read(reader, String)\nend\n\n# output\n\"Hello, world!\"","category":"page"},{"location":"writers/#Reference","page":"Writers","title":"Reference","text":"","category":"section"},{"location":"writers/#BGZFLib.BGZFWriter-writers","page":"Writers","title":"BGZFLib.BGZFWriter","text":"BGZFWriter(io::T <: AbstractBufWriter; kwargs)::BGZFWriter{T}\nBGZFWriter(io::T <: IO; kwargs)::BGZFWriter{BufWriter{T}}\n\nCreate a SyncBGZFWriter <: AbstractBufWriter that writes compresses data written to it, and writes the compressed BGZF file to the underlying io.\n\nThis type differs from SyncBGZFWriter in that the compression happens in separate worker tasks. This allows BGZFWriter to compress in parallel, making it faster in the presence of multiple threads.\n\nIf io::AbstractBufWriter, io must be able to buffer up to 2^16 bytes, else a BGZFError(nothing, BGZFErrors.insufficient_writer_space) is thrown.\n\nThe keyword arguments are:\n\nn_workers::Int: Set number of workers. Must be > 0. Defaults to some small number.\ncompress_level::Int: Set compression level from 1 to 12, with 12 being slowest but with the best compression ratio. It defaults to an intermediate level of compression.\nappend_empty::Bool = true. If set, closing the SyncBGZFWriter will write an empty BGZF block, indicating EOF.\n\n\n\n\n\n","category":"type"},{"location":"writers/#BGZFLib.SyncBGZFWriter-writers","page":"Writers","title":"BGZFLib.SyncBGZFWriter","text":"SyncBGZFWriter(io::T <: AbstractBufWriter; kwargs)::SyncBGZFWriter{T}\nSyncBGZFWriter(io::T <: IO; kwargs)::SyncBGZFWriter{BufWriter{T}}\n\nCreate a SyncBGZFWriter <: AbstractBufWriter that writes compresses data written to it, and writes the compressed BGZF file to the underlying io.\n\nThis type differs from BGZFWriter in that it does the compression serial in the main task. Therefore it is slower when multiple threads are present, but does not incur Task- and scheduling overhead.\n\nIf io::AbstractBufWriter, io must be able to buffer up to 2^16 bytes, else a BGZFError(nothing, BGZFErrors.insufficient_writer_space) is thrown.\n\nThe keyword arguments are:\n\ncompresslevel::Int: Set compression level from 1 to 12, with 12 being slowest but with the best compression ratio. It defaults to an intermediate level of compression.\nappend_empty::Bool = true. If set, closing the SyncBGZFWriter will write an empty BGZF block, indicating EOF.\n\n\n\n\n\n","category":"type"}]
}
