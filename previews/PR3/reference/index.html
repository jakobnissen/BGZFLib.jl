<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · BGZFLib.jl</title><meta name="title" content="Reference · BGZFLib.jl"/><meta property="og:title" content="Reference · BGZFLib.jl"/><meta property="twitter:title" content="Reference · BGZFLib.jl"/><meta name="description" content="Documentation for BGZFLib.jl."/><meta property="og:description" content="Documentation for BGZFLib.jl."/><meta property="twitter:description" content="Documentation for BGZFLib.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BGZFLib.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">BGZFLib</a></li><li><a class="tocitem" href="../readers/">Readers</a></li><li><a class="tocitem" href="../writers/">Writers</a></li><li><a class="tocitem" href="../gzindex/">Seeking</a></li><li class="is-active"><a class="tocitem" href>Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.BGZFError" href="#BGZFLib.BGZFError"><code>BGZFLib.BGZFError</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BGZFError &lt;: Exception</code></pre><p>Exception type thrown by BGZF readers and writers, when encountering errors specific to the BGZF (or gzip, or DEFLATE) formats. Note that exceptions thrown by BGZF readers and writers are not guaranteed to be of this type, as they may also throw <code>BufferIO.IOError</code>s, or exceptions propagated by their underlying IO.</p><p>This error contains two public properties:</p><ul><li><code>block_offset::Union{Nothing, Int}</code> gives the zero-based offset in the compressed stream  of the block where the error occurred.  Some errors may not occur at a specific block, in which case this is <code>nothing</code>.</li><li><code>type::Union{BGZFErrorType, LibDeflateError}</code>. If the blocks are malformed gzip blocks, this  is a <code>LibDeflateError</code>. Else, if the error is specific to the BGZF format, it&#39;s a BGZFErrorType.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.BGZFReader" href="#BGZFLib.BGZFReader"><code>BGZFLib.BGZFReader</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BGZFReader(io::T &lt;: IO; n_workers::Int, check_truncated::Bool=true)::BGZFReader{BufReader{T}}
BGZFReader(io::T &lt;: AbstractBufReader; n_workers::Int, check_truncated::Bool=true)::BGZFReader{T}</code></pre><p>Create a <code>BGZFReader &lt;: AbstractBufReader</code> that decompresses a BGZF stream.</p><p>When constructing from an <code>io::AbstractBufReader</code>, <code>io</code> must have a buffer size of at least 65536, or be able to grow its buffer to this size.</p><p>If <code>check_truncated</code>, the last BGZF block in the file must be empty, otherwise the reader throws an error. This can be used to detect the file was truncated.</p><p>The decompression happens asyncronously in a set of worker tasks. To avoid spawning workers, use the <code>SyncBGZFReader</code> instead.</p><p>If the reader encounters an error, it goes into an error state and throws an exception. The reader can be reset by using <code>seek</code> or <code>seekstart</code>. A closed reader cannot be reset.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.BGZFWriter" href="#BGZFLib.BGZFWriter"><code>BGZFLib.BGZFWriter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BGZFWriter(io::T &lt;: AbstractBufWriter; kwargs)::BGZFWriter{T}
BGZFWriter(io::T &lt;: IO; kwargs)::BGZFWriter{BufWriter{T}}</code></pre><p>Create a <code>SyncBGZFWriter &lt;: AbstractBufWriter</code> that writes compresses data written to it, and writes the compressed BGZF file to the underlying <code>io</code>.</p><p>This type differs from <code>SyncBGZFWriter</code> in that the compression happens in separate worker tasks. This allows <code>BGZFWriter</code> to compress in parallel, making it faster in the presence of multiple threads.</p><p>If <code>io::AbstractBufWriter</code>, <code>io</code> must be able to buffer up to 2^16 bytes, else a <code>BGZFError(nothing, BGZFErrors.insufficient_writer_space)</code> is thrown.</p><p>The keyword arguments are:</p><ul><li><code>n_workers::Int</code>: Set number of workers. Must be &gt; 0. Defaults to some small number.</li><li><code>compress_level::Int</code>: Set compression level from 1 to 12, with 12 being slowest but with the best compression ratio. It defaults to an intermediate level of compression.</li><li><code>append_empty::Bool = true</code>. If set, closing the <code>SyncBGZFWriter</code> will write an empty BGZF block, indicating EOF.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.GZIndex" href="#BGZFLib.GZIndex"><code>BGZFLib.GZIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GZIndex(blocks::Vector{@NamedTuple{compressed_offset::UInt64, decompressed_offset::UInt64}})</code></pre><p>Construct a GZI index of a BGZF file. The vector <code>blocks</code> contains one pair of integers for each block in the BGZF file, in order, containing the zero-based offset of the compressed data and the corresponding decompressed data, respectively.</p><p>Throw a <code>BGZFError(nothing, BGZFErrors.unsorted_index)</code> if either of the offsets are not sorted in ascending order.</p><p>Usually constructed with <a href="../gzindex/#BGZFLib.index_bgzf-gzindex"><code>index_bgzf</code></a>, or <a href="../gzindex/#BGZFLib.load_gzi-gzindex"><code>load_gzi</code></a> and serialized with <code>write(io, ::GZIndex)</code>.</p><p>This struct contains the public property <code>.blocks</code> which corresponds to the vector as described above, no matter how <code>GZIndex</code> is constructed.</p><p>See also: <a href="../gzindex/#BGZFLib.index_bgzf-gzindex"><code>index_bgzf</code></a>, <a href="../gzindex/#BGZFLib.load_gzi-gzindex"><code>load_gzi</code></a>, <a href="../gzindex/#BGZFLib.write_gzi-gzindex"><code>write_gzi</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.SyncBGZFReader" href="#BGZFLib.SyncBGZFReader"><code>BGZFLib.SyncBGZFReader</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncBGZFReader(io::T &lt;: IO; check_truncated::Bool=true)::SyncBGZFReader{BufReader{T}}
SyncBGZFReader(io::T &lt;: AbstractBufReader; check_truncated::Bool=true)::SyncBGZFReader{T}</code></pre><p>Create a <code>SyncBGZFReader &lt;: AbstractBufReader</code> that decompresses BGZF files.</p><p>When constructing from an <code>io::AbstractBufReader</code>, <code>io</code> must have a buffer size of at least 65536, or be able to grow its buffer to this size.</p><p>If <code>check_truncated</code>, the last BGZF block in the file must be empty, otherwise the reader throws an error. This can be used to detect the file was truncated.</p><p>Unlike <code>BGZFReader</code>, the decompression happens in in serial in the main task. This is slower and does not enable paralellism, but may be preferable in situations where task scheduling or contention is an issue.</p><p>If the reader encounters an error, it goes into an error state and throws an exception. The reader can be reset by using <code>seek</code> or <code>seekstart</code>. A closed reader cannot be reset.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.SyncBGZFWriter" href="#BGZFLib.SyncBGZFWriter"><code>BGZFLib.SyncBGZFWriter</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SyncBGZFWriter(io::T &lt;: AbstractBufWriter; kwargs)::SyncBGZFWriter{T}
SyncBGZFWriter(io::T &lt;: IO; kwargs)::SyncBGZFWriter{BufWriter{T}}</code></pre><p>Create a <code>SyncBGZFWriter &lt;: AbstractBufWriter</code> that writes compresses data written to it, and writes the compressed BGZF file to the underlying <code>io</code>.</p><p>This type differs from <code>BGZFWriter</code> in that it does the compression serial in the main task. Therefore it is slower when multiple threads are present, but does not incur Task- and scheduling overhead.</p><p>If <code>io::AbstractBufWriter</code>, <code>io</code> must be able to buffer up to 2^16 bytes, else a <code>BGZFError(nothing, BGZFErrors.insufficient_writer_space)</code> is thrown.</p><p>The keyword arguments are:</p><ul><li><code>compresslevel::Int</code>: Set compression level from 1 to 12, with 12 being slowest but with the best compression ratio. It defaults to an intermediate level of compression.</li><li><code>append_empty::Bool = true</code>. If set, closing the <code>SyncBGZFWriter</code> will write an empty BGZF block, indicating EOF.</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.VirtualOffset" href="#BGZFLib.VirtualOffset"><code>BGZFLib.VirtualOffset</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VirtualOffset(file_offset::Integer, block_offset::Integer)</code></pre><p>Create a BGZF virtual file offset from <code>file_offset</code> and <code>block_offset</code>. Get the two offsets with the public properties <code>vo.file_offset</code> and <code>vo.block_offset</code></p><p>A <code>VirtualOffset</code> contains the two zero-indexed offset: The &quot;file offset&quot;, which is the offset in the <em>compressed</em> BGZF file that marks the beginning of the block with the given position, and an &quot;block offset&quot; which is the offset of the <em>uncompressed</em> content of that block.</p><p>The valid ranges of these two are <code>0:2^48-1</code> and <code>0:2^16-1</code>, respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reader = SyncBGZFReader(CursorReader(bgzf_data));

julia&gt; vo = VirtualOffset(178, 5)
VirtualOffset(178, 5)

julia&gt; virtual_seek(reader, vo);

julia&gt; String(read(reader, 9))
&quot;some more&quot;

julia&gt; virtual_seek(reader, VirtualOffset(0, 7));

julia&gt; String(read(reader, 6))
&quot;world!&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.index_bgzf-Tuple{IO}" href="#BGZFLib.index_bgzf-Tuple{IO}"><code>BGZFLib.index_bgzf</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">index_bgzf(io::Union{IO, AbstractBufReader})::GZIndex</code></pre><p>Compute a <code>GZIndex</code> from a BGZF file.</p><p>Throw a <code>BGZFError</code> if the BGZF file is invalid, or a <code>BGZFError</code> with <code>BGZFErrors.insufficient_reader_space</code> if an entire block cannot be buffered by <code>io</code>, (only happens if <code>io::AbstractBufReader</code>).</p><p>Indexing the file does not attempt to decompress it, and therefore does not validate that the compressed data is valid (i.e. is a valid DEFLATE payload, or that the crc32 checksum matches).</p><p>See also: <a href="../gzindex/#BGZFLib.load_gzi-gzindex"><code>load_gzi</code></a>, <a href="#BGZFLib.GZIndex"><code>GZIndex</code></a>, <a href="../gzindex/#BGZFLib.write_gzi-gzindex"><code>write_gzi</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; idx1 = open(index_bgzf, path_to_bgzf);

julia&gt; idx2 = open(load_gzi, path_to_gzi);

julia&gt; idx1.blocks == idx2.blocks
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.load_gzi-Tuple{IO}" href="#BGZFLib.load_gzi-Tuple{IO}"><code>BGZFLib.load_gzi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_gzi(io::Union{IO, AbstractBufReader})::GZIndex</code></pre><p>Load a <code>GZIndex</code> from a GZI file.</p><p>Throw an <code>IOError(IOErrorKinds.EOF)</code> if <code>io</code> does not contain enough bytes for a valid GZI file. Throw a <code>BGZFError(nothing, BGZFErrors.unsorted_index)</code> if the offsets are not sorted in ascending order. Currently does not throw an error if the file contains extra appended bytes, but this may change in the future.</p><p>See also: <a href="../gzindex/#BGZFLib.index_bgzf-gzindex"><code>index_bgzf</code></a>, <a href="#BGZFLib.GZIndex"><code>GZIndex</code></a>, <a href="../gzindex/#BGZFLib.write_gzi-gzindex"><code>write_gzi</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gzi = open(load_gzi, path_to_gzi);

julia&gt; gzi isa GZIndex
true

julia&gt; (; compressed_offset) = gzi.blocks[5]
(compressed_offset = 0x0000000000000093, decompressed_offset = 0x0000000000000017)

julia&gt; reader = SyncBGZFReader(CursorReader(bgzf_data));

julia&gt; seek(reader, Int(compressed_offset));

julia&gt; read(reader, 15) |&gt; String
&quot;then some morem&quot;

julia&gt; close(reader)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.virtual_position-Tuple{SyncBGZFReader}" href="#BGZFLib.virtual_position-Tuple{SyncBGZFReader}"><code>BGZFLib.virtual_position</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">virtual_position(io::Union{SyncBGZFReader, BGZFReader})::VirtualOffset</code></pre><p>Get the <code>VirtualOffset</code> of the current BGZF reader. The virtual offset is a position in the decompressed stream. Seek to the position using <code>virtual_seek</code>.</p><p>See also: <a href="#BGZFLib.VirtualOffset"><code>VirtualOffset</code></a>, <a href="../gzindex/#BGZFLib.virtual_seek-gzindex"><code>virtual_seek</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reader = SyncBGZFReader(CursorReader(bgzf_data));

julia&gt; virtual_position(reader)
VirtualOffset(0, 0)

julia&gt; read(reader, 18);

julia&gt; virtual_position(reader)
VirtualOffset(44, 5)

julia&gt; close(reader)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.virtual_seek-Tuple{SyncBGZFReader, VirtualOffset}" href="#BGZFLib.virtual_seek-Tuple{SyncBGZFReader, VirtualOffset}"><code>BGZFLib.virtual_seek</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">virtual_seek(io::Union{SyncBGZFReader, BGZFReader}, vo::VirtualOffset) -&gt; io</code></pre><p>Seek to the virtual position <code>vo</code>. The virtual position is usually obtained by a call to <code>virtual_position</code>.</p><p>See also: <a href="#BGZFLib.VirtualOffset"><code>VirtualOffset</code></a>, <a href="../gzindex/#BGZFLib.virtual_position-gzindex"><code>virtual_position</code></a></p><pre><code class="language-julia-repl hljs">julia&gt; reader = SyncBGZFReader(CursorReader(bgzf_data));

julia&gt; virtual_seek(reader, VirtualOffset(178, 14));

julia&gt; String(read(reader))
&quot;more content herethis is another block&quot;

julia&gt; virtual_seek(reader, VirtualOffset(0, 0));

julia&gt; String(read(reader, 13))
&quot;Hello, world!&quot;

julia&gt; close(reader)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.write_empty_block-Tuple{SyncBGZFWriter}" href="#BGZFLib.write_empty_block-Tuple{SyncBGZFWriter}"><code>BGZFLib.write_empty_block</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_empty_block(io::Union{SyncBGZFWriter, BGZFWriter})</code></pre><p>Perform a shallow_flush, then write an empty block.</p><p><strong>Examples</strong></p><p>Write the final empty EOF block manually:</p><pre><code class="language-julia-repl hljs">julia&gt; io = VecWriter();

julia&gt; SyncBGZFWriter(io; append_empty=false) do writer
           write(writer, &quot;Hello&quot;)
           # Manually write the empty EOF block
           write_empty_block(writer)
       end

julia&gt; SyncBGZFReader(CursorReader(io.vec); check_truncated=true) do reader
           read(reader, String)
       end
&quot;Hello&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.write_gzi-Tuple{Union{BufferIO.AbstractBufWriter, IO}, GZIndex}" href="#BGZFLib.write_gzi-Tuple{Union{BufferIO.AbstractBufWriter, IO}, GZIndex}"><code>BGZFLib.write_gzi</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_gzi(io::Union{AbstractBufWriter, IO}, index::GZIndex)::Int</code></pre><p>Write a <code>GZIndex</code> to <code>io</code> in GZI format, and return the number of written bytes. Currently, this function only works on little-endian CPUs, and will throw an <code>ErrorException</code> on big-endian platforms.</p><p>The resulting file can be loaded with <a href="../gzindex/#BGZFLib.load_gzi-gzindex"><code>load_gzi</code></a> and obtain an index equivalent to <code>index</code>.</p><p>See also: <a href="#BGZFLib.GZIndex"><code>GZIndex</code></a>, <a href="../gzindex/#BGZFLib.index_bgzf-gzindex"><code>index_bgzf</code></a>    </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gzi = load_gzi(CursorReader(gzi_data))::GZIndex;

julia&gt; io = VecWriter();

julia&gt; write_gzi(io, gzi)
152

julia&gt; gzi_2 = load_gzi(CursorReader(io.vec));

julia&gt; gzi.blocks == gzi_2.blocks
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.BGZFErrors" href="#BGZFLib.BGZFErrors"><code>BGZFLib.BGZFErrors</code></a> — <span class="docstring-category">Module</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">module BGZFErrors</code></pre><p>This module is used as a namespace for the enum <code>BGZFErrorType</code>. The enum is non-exhaustive (more variants may be added in the future). The current values are:</p><ul><li><code>truncated_file</code>: The reader data stops abruptly. Either in the middle of a block, or there is no empty block at EOF</li><li><code>missing_bc_field</code>: A block has no <code>BC</code> field, or it&#39;s malformed</li><li><code>block_offset_out_of_bounds</code>: Seek with a <code>VirtualOffset</code> where the block offset is larger than the block size</li><li><code>insufficient_reader_space</code>: The BGZF reader wraps an <code>AbstractBufWriter</code> that is not EOF, and its buffer can&#39;t grow to encompass a whole BGZF block</li><li><code>insufficient_writer_space</code>: A BGZF writer wraps an <code>AbstractBufWriter</code> whose buffer cannot grow to encompass a full BGZF block</li><li><code>unsorted_index</code>: Attempted to load a malformed GZI file with unsorted coordinates</li><li><code>operation_on_error</code>: Attempted an operation on a BGZF reader or writer in an error state.</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../gzindex/">« Seeking</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 13 October 2025 12:53">Monday 13 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
