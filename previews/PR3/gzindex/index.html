<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Seeking · BGZFLib.jl</title><meta name="title" content="Seeking · BGZFLib.jl"/><meta property="og:title" content="Seeking · BGZFLib.jl"/><meta property="twitter:title" content="Seeking · BGZFLib.jl"/><meta name="description" content="Documentation for BGZFLib.jl."/><meta property="og:description" content="Documentation for BGZFLib.jl."/><meta property="twitter:description" content="Documentation for BGZFLib.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">BGZFLib.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">BGZFLib</a></li><li><a class="tocitem" href="../readers/">Readers</a></li><li><a class="tocitem" href="../writers/">Writers</a></li><li class="is-active"><a class="tocitem" href>Seeking</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Seeking</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Seeking</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Seeking-BGZF-files"><a class="docs-heading-anchor" href="#Seeking-BGZF-files">Seeking BGZF files</a><a id="Seeking-BGZF-files-1"></a><a class="docs-heading-anchor-permalink" href="#Seeking-BGZF-files" title="Permalink"></a></h1><p>Due to their blocked nature, it is possible to seek BGZF files, and to index them to support seeking to any position in the equivalent <em>decompressed</em> stream.</p><p>Currently, only BGZF reader support seeking. Seek support for writers may be added in the future.</p><h3 id="Virtual-seeking"><a class="docs-heading-anchor" href="#Virtual-seeking">Virtual seeking</a><a id="Virtual-seeking-1"></a><a class="docs-heading-anchor-permalink" href="#Virtual-seeking" title="Permalink"></a></h3><p>A BGZF reader is seeked with a <em>virtual offset</em>, which contains two offsets: The <em>file offset</em>, which is the offset in the compressed stream that marks the start of the compressed BGZF block, and the <em>block offset</em>, the offset in the decompressed content of that block.</p><p>This is modeled by the <code>VirtualOffset</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.VirtualOffset-gzindex" href="#BGZFLib.VirtualOffset-gzindex"><code>BGZFLib.VirtualOffset</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VirtualOffset(file_offset::Integer, block_offset::Integer)</code></pre><p>Create a BGZF virtual file offset from <code>file_offset</code> and <code>block_offset</code>. Get the two offsets with the public properties <code>vo.file_offset</code> and <code>vo.block_offset</code></p><p>A <code>VirtualOffset</code> contains the two zero-indexed offset: The &quot;file offset&quot;, which is the offset in the <em>compressed</em> BGZF file that marks the beginning of the block with the given position, and an &quot;block offset&quot; which is the offset of the <em>uncompressed</em> content of that block.</p><p>The valid ranges of these two are <code>0:2^48-1</code> and <code>0:2^16-1</code>, respectively.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reader = SyncBGZFReader(CursorReader(bgzf_data));

julia&gt; vo = VirtualOffset(178, 5)
VirtualOffset(178, 5)

julia&gt; virtual_seek(reader, vo);

julia&gt; String(read(reader, 9))
&quot;some more&quot;

julia&gt; virtual_seek(reader, VirtualOffset(0, 7));

julia&gt; String(read(reader, 6))
&quot;world!&quot;</code></pre></div></section></article><p>The current <code>VirtualOffset</code> position is obtained with <code>virtual_position</code>, and seeking is done with <code>virtual_seek</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.virtual_position-gzindex" href="#BGZFLib.virtual_position-gzindex"><code>BGZFLib.virtual_position</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">virtual_position(io::Union{SyncBGZFReader, BGZFReader})::VirtualOffset</code></pre><p>Get the <code>VirtualOffset</code> of the current BGZF reader. The virtual offset is a position in the decompressed stream. Seek to the position using <code>virtual_seek</code>.</p><p>See also: <a href="../reference/#BGZFLib.VirtualOffset"><code>VirtualOffset</code></a>, <a href="#BGZFLib.virtual_seek-gzindex"><code>virtual_seek</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reader = SyncBGZFReader(CursorReader(bgzf_data));

julia&gt; virtual_position(reader)
VirtualOffset(0, 0)

julia&gt; read(reader, 18);

julia&gt; virtual_position(reader)
VirtualOffset(44, 5)

julia&gt; close(reader)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.virtual_seek-gzindex" href="#BGZFLib.virtual_seek-gzindex"><code>BGZFLib.virtual_seek</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">virtual_seek(io::Union{SyncBGZFReader, BGZFReader}, vo::VirtualOffset) -&gt; io</code></pre><p>Seek to the virtual position <code>vo</code>. The virtual position is usually obtained by a call to <code>virtual_position</code>.</p><p>See also: <a href="../reference/#BGZFLib.VirtualOffset"><code>VirtualOffset</code></a>, <a href="#BGZFLib.virtual_position-gzindex"><code>virtual_position</code></a></p><pre><code class="language-julia-repl hljs">julia&gt; reader = SyncBGZFReader(CursorReader(bgzf_data));

julia&gt; virtual_seek(reader, VirtualOffset(178, 14));

julia&gt; String(read(reader))
&quot;more content herethis is another block&quot;

julia&gt; virtual_seek(reader, VirtualOffset(0, 0));

julia&gt; String(read(reader, 13))
&quot;Hello, world!&quot;

julia&gt; close(reader)</code></pre></div></section></article><p>BGZF readers also supports <code>Base.seek</code>. Calling <code>seek(io, x)</code> is equivalent to <code>virtual_seek(io, VirtualOffset(x, 0))</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.seek-Tuple{SyncBGZFReader, Int64}-gzindex" href="#Base.seek-Tuple{SyncBGZFReader, Int64}-gzindex"><code>Base.seek</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">seek(io::Union{SyncBGZFReader, BGZFReader}, offset::Int)</code></pre><p>Seek to the zero-indexed position in the <em>compressed stream</em> <code>offset</code>. This position must be the beginning of a BGZF block, else the reader will error when trying to read after the seek. <code>seek(io, offset)</code> is equivalent to <code>seek(io, VirtualOffset(offset, 0))</code>. <code>seek(io, 0)</code> works, and is equivalent to <code>seekstart(io)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reader = BGZFReader(CursorReader(bgzf_data));

julia&gt; seek(reader, 44);

julia&gt; read(reader, String)
&quot;more dataxthen some moremore content herethis is another block&quot;

julia&gt; seek(reader, 45); # NB: Not start of BGZF block

julia&gt; read(reader, UInt8)
ERROR: BGZFError(0, LibDeflate.LibDeflateErrors.gzip_bad_magic_bytes)

julia&gt; close(reader)</code></pre></div></section></article><h3 id="Seeking-with-GZIndex"><a class="docs-heading-anchor" href="#Seeking-with-GZIndex">Seeking with <code>GZIndex</code></a><a id="Seeking-with-GZIndex-1"></a><a class="docs-heading-anchor-permalink" href="#Seeking-with-GZIndex" title="Permalink"></a></h3><p>In order to seek to a certain <em>decompressed offset</em>, e.g. to seek to the 10,000th byte in a decompressed stream, you need to know the offset of the BGZF block that contains this byte in the <em>compressed stream</em>. This can be efficiently obtained with a <code>GZIndex</code>.</p><p>An <code>index::GZIndex</code> value contains the (public) property <code>index.blocks</code>, which is a <code>Vector{@NamedTuple{compressed_offset::UInt64, decompressed_offset::UInt64}}</code>, with one element for each block in the corresponding file. All the values of <code>compressed_offset</code> and <code>decompressed_offset</code> are guaranteed to be sorted in ascending order in a <code>GZIndex</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.GZIndex-gzindex" href="#BGZFLib.GZIndex-gzindex"><code>BGZFLib.GZIndex</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GZIndex(blocks::Vector{@NamedTuple{compressed_offset::UInt64, decompressed_offset::UInt64}})</code></pre><p>Construct a GZI index of a BGZF file. The vector <code>blocks</code> contains one pair of integers for each block in the BGZF file, in order, containing the zero-based offset of the compressed data and the corresponding decompressed data, respectively.</p><p>Throw a <code>BGZFError(nothing, BGZFErrors.unsorted_index)</code> if either of the offsets are not sorted in ascending order.</p><p>Usually constructed with <a href="#BGZFLib.index_bgzf-gzindex"><code>index_bgzf</code></a>, or <a href="#BGZFLib.load_gzi-gzindex"><code>load_gzi</code></a> and serialized with <code>write(io, ::GZIndex)</code>.</p><p>This struct contains the public property <code>.blocks</code> which corresponds to the vector as described above, no matter how <code>GZIndex</code> is constructed.</p><p>See also: <a href="#BGZFLib.index_bgzf-gzindex"><code>index_bgzf</code></a>, <a href="#BGZFLib.load_gzi-gzindex"><code>load_gzi</code></a>, <a href="#BGZFLib.write_gzi-gzindex"><code>write_gzi</code></a></p></div></section></article><p>Let&#39;s say you want to seek to the decompressed offset 37 in our example BGZF file. The approach is this:</p><ul><li>Find the first block with a decompressed offset <code>D &lt;= 37</code>. Since <code>.blocks</code> is sorted, you can use binary search for this.</li><li>Virtualseek to <code>VirtalOffset(D, 37 - D)</code></li></ul><pre><code class="language-julia hljs">gzi = load_gzi(CursorReader(gzi_data))
reader = SyncBGZFReader(CursorReader(bgzf_data))

# Use `searchsortedlast` to find the last block with a decompressed offset
# &lt;= 37, i.e. the block containing the decompressed offset 37.
target_block = (;compressed_offset=0, decompressed_offset=37)
idx = searchsortedlast(gzi.blocks, target_block, by=i -&gt; i.decompressed_offset)
(;compressed_offset, decompressed_offset) = gzi.blocks[idx]
virtual_seek(reader, VirtualOffset(compressed_offset, 37 - decompressed_offset))
read(reader) |&gt; String

# output
&quot;more content herethis is another block&quot;</code></pre><h4 id="Building-a-GZIndex"><a class="docs-heading-anchor" href="#Building-a-GZIndex">Building a <code>GZIndex</code></a><a id="Building-a-GZIndex-1"></a><a class="docs-heading-anchor-permalink" href="#Building-a-GZIndex" title="Permalink"></a></h4><p>A GZIndex can be constructed manually from a correct (and sorted) vector <code>v</code> of the above mentioned type using <code>GZIndex(v)</code>. More commonly, it is either computed from a BGZF file, or directly loaded from a GZI file:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.index_bgzf-gzindex" href="#BGZFLib.index_bgzf-gzindex"><code>BGZFLib.index_bgzf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">index_bgzf(io::Union{IO, AbstractBufReader})::GZIndex</code></pre><p>Compute a <code>GZIndex</code> from a BGZF file.</p><p>Throw a <code>BGZFError</code> if the BGZF file is invalid, or a <code>BGZFError</code> with <code>BGZFErrors.insufficient_reader_space</code> if an entire block cannot be buffered by <code>io</code>, (only happens if <code>io::AbstractBufReader</code>).</p><p>Indexing the file does not attempt to decompress it, and therefore does not validate that the compressed data is valid (i.e. is a valid DEFLATE payload, or that the crc32 checksum matches).</p><p>See also: <a href="#BGZFLib.load_gzi-gzindex"><code>load_gzi</code></a>, <a href="../reference/#BGZFLib.GZIndex"><code>GZIndex</code></a>, <a href="#BGZFLib.write_gzi-gzindex"><code>write_gzi</code></a></p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; idx1 = open(index_bgzf, path_to_bgzf);

julia&gt; idx2 = open(load_gzi, path_to_gzi);

julia&gt; idx1.blocks == idx2.blocks
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.load_gzi-gzindex" href="#BGZFLib.load_gzi-gzindex"><code>BGZFLib.load_gzi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">load_gzi(io::Union{IO, AbstractBufReader})::GZIndex</code></pre><p>Load a <code>GZIndex</code> from a GZI file.</p><p>Throw an <code>IOError(IOErrorKinds.EOF)</code> if <code>io</code> does not contain enough bytes for a valid GZI file. Throw a <code>BGZFError(nothing, BGZFErrors.unsorted_index)</code> if the offsets are not sorted in ascending order. Currently does not throw an error if the file contains extra appended bytes, but this may change in the future.</p><p>See also: <a href="#BGZFLib.index_bgzf-gzindex"><code>index_bgzf</code></a>, <a href="../reference/#BGZFLib.GZIndex"><code>GZIndex</code></a>, <a href="#BGZFLib.write_gzi-gzindex"><code>write_gzi</code></a></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gzi = open(load_gzi, path_to_gzi);

julia&gt; gzi isa GZIndex
true

julia&gt; (; compressed_offset) = gzi.blocks[5]
(compressed_offset = 0x0000000000000093, decompressed_offset = 0x0000000000000017)

julia&gt; reader = SyncBGZFReader(CursorReader(bgzf_data));

julia&gt; seek(reader, Int(compressed_offset));

julia&gt; read(reader, 15) |&gt; String
&quot;then some morem&quot;

julia&gt; close(reader)</code></pre></div></section></article><h4 id="Writing-GZI-files"><a class="docs-heading-anchor" href="#Writing-GZI-files">Writing GZI files</a><a id="Writing-GZI-files-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-GZI-files" title="Permalink"></a></h4><p>This is done with <code>write_gzi</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BGZFLib.write_gzi-gzindex" href="#BGZFLib.write_gzi-gzindex"><code>BGZFLib.write_gzi</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">write_gzi(io::Union{AbstractBufWriter, IO}, index::GZIndex)::Int</code></pre><p>Write a <code>GZIndex</code> to <code>io</code> in GZI format, and return the number of written bytes. Currently, this function only works on little-endian CPUs, and will throw an <code>ErrorException</code> on big-endian platforms.</p><p>The resulting file can be loaded with <a href="#BGZFLib.load_gzi-gzindex"><code>load_gzi</code></a> and obtain an index equivalent to <code>index</code>.</p><p>See also: <a href="../reference/#BGZFLib.GZIndex"><code>GZIndex</code></a>, <a href="#BGZFLib.index_bgzf-gzindex"><code>index_bgzf</code></a>    </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; gzi = load_gzi(CursorReader(gzi_data))::GZIndex;

julia&gt; io = VecWriter();

julia&gt; write_gzi(io, gzi)
152

julia&gt; gzi_2 = load_gzi(CursorReader(io.vec));

julia&gt; gzi.blocks == gzi_2.blocks
true</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../writers/">« Writers</a><a class="docs-footer-nextpage" href="../reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 13 October 2025 12:42">Monday 13 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
